# Java复习

# spring

# sprin七大组件

1. 核心容器Springb core

2. Spring上下文Spring context：Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能

3. Spring面向切面编程Spring AOP

4. Spring DAO模块：DAO模式主要目的是将持久层相关问题与一般的的业务规则和工作流隔离开来

5. Spring ORM模块

6. Spring Web模块：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文，Web层使用Web层框架，可选的，可以是Spring自己的MVC框架，或者提供的Web框架，如Struts、Webwork、tapestry和jsf。

7. Spring MVC框架SpringWebMVC

## spring框架

spring核心是IOC（控制反转）、AOP（面向切面编程）、DI（依赖注入）

- IOC控制反转是指创建对象的控制权的转移，由编程人员主动把控，转移到spring容器中，并且由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。最直观的表达就是，IOC让对象的创建不用去new，可以由spring根据我们提供的配置文件自动生成，我们直接从spring容器中获取即可。

- DI依赖注入指应用程序运行时依赖ioc容器来动态注入对象需要的外部资源。<mark>具体怎么进行依赖？</mark>

- AOP用于将与业务无关的，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块。 SpringAOP使用的动态代理方式，所谓动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理。

### 如何解决循环依赖

使用三级缓存

- 一级缓存：singletonObjects，也叫单例池，存放已经经历了完整生命周期的Bean对象。

- 二级缓存：earlySingletonObjects，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完整）。

- 三级缓存：singletonFactories，Map<Stirng,ObjectFactory<?>> ，存放可以生产Bean的工厂。

### 动态代理

1. jdk动态代理只提供接口代理，不支持类代理，核心InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起，Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。

2. CGLIB是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么就无法使用CGLIB做动态代理。

当被代理类有实现接口的情况下，那么使用的是jdk动态代理，否则使用的是CGLIB动态代理

#### jdk动态代理和cglib动态区别

- jdk动态代理是实现了呗代理对象的接口，cglib是继承了呗代理对象。

- jdk和cglib都是在运行时期生成字节码，jdk是直接写class字节码，cglib使用asm框架写class。

- jdk调用代理方法是通过反射机制调用，cglib是通过FastClass机制直接调用方法。

## spring的生命周期

1. 实例化一个Bean，也就是我们通常说的new

2. 按照spring上下文对实例化的Bean进行配置，也就是IOC注入。

3. 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName方法，传递的是spring配置文件中Bean的ID。

4. 如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是spring工厂本身（可以用这个方法获取到其他Bean）

5. 如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext方法，传入spring上下文。

6. 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个实在Bean初始化结束时调用After方法，也可用于内存或缓存技术.

7. 如果这个Bean在spring配置文件中配置了init-method属性会自动调用其配置初始化方法。

8. 如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialication方法。

注：以上工作完成后就可以使用这个Bean，这个Bean是一个single的，所以一般情况下我们调用同一个ID的Bean会是在内容地址相同的实例。

   9.当Bean不再需要时，会经历清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法。

    10.最后，如果这个Bean的spring配置中配置了destroy0method属性，会自动调用其配置的销毁方法。

### Bean创建周期

大致可以分为5个阶段：创建前准备、创建实例化、依赖注入、容器缓存和销毁实例；

一、创建前准备

![](C:\Users\admin\AppData\Roaming\marktext\images\2022-08-11-15-01-09-image.png)

> 实例化BeanFactoryPostProcessor
> 
> <mark>BeanFactoryPostProcessor会比Bean先实例化</mark>
> 
>                             |
> 
> 实例化BeanPostProcessor
> 
>                             |
> 
> 实例化BeanPostProcessor实现类
> 
>                             |
> 
> 实例化InstantiationAwareBeanPostProcessorAdapter实现类（实例化感知的Bwan后置处理器）
> 
>                             |
> 
> 执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法（在实例化之前的后置处理）
> 
> <mark>在目标Bean被实例化之前先执行此处理器的逻辑</mark>

这个阶段的主要作用是bean在开始加载前，要在上下文和配置中去解析和查找bean有关的扩展实现比如init-method、destroy-method、BeanfactoryPostProcessor等一些bean在加载过程中的前置和后置的一些扩展实现。

二、创建实例阶段

![](C:\Users\admin\AppData\Roaming\marktext\images\2022-08-11-15-05-58-image.png)

> 执行Bean的构造器
> 
> <mark>正式创建Bean</mark>
> 
>             |
> 
> 执行InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法
> 
> <mark>当依赖注入发生前，Java对象以及创建，但是SpringBean还不对外可用</mark>

这个阶段的主要作用是通过反射去创建bean的实例对象，并且会扫描和解析bean声明的一些属性。

三、依赖注入阶段

![](C:\Users\admin\AppData\Roaming\marktext\images\2022-08-11-15-07-30-image.png)

> 为Bean注入属性
> 
>             
> 
> 调用BeanNameAware的setBeanName()方法
> 
>                                    |  ——————> <mark>先设置Bean的name再创建Bean的Factory</mark>
> 
> 调用BeanFactoryAware的setBeanFactory()方法
> 
>                                    |
> 
> 执行BeanPostProcessor的PostProcessBeforeInitialization()方法（后置处理器再实例化之前的方法）
> 
> **所有初始化动作（如afterPropertiesSet、init-method等）回调之前，都将把BeanPostProcessor赋值给新创建的Bean**
> 
>                                    |
> 
> 调用InitializingBean的afterPropertieSet()方法
> 
> **设置好所有的Bean属性之后，由BeanFactory调用**

如果被实例化的bean存在依赖其他bean对象的情况，则需要对这些依赖的bean进行对象注入，在这个阶段会触发一些扩展调用，比如BeanPostProcessors：用来实现bean初始化前后的扩展回调，以及BeanFactoryAware等等。

四、容器缓存阶段

![](C:\Users\admin\AppData\Roaming\marktext\images\2022-08-11-15-21-05-image.png)

> 调用Bean的init-method方法（在配置中属性指定的方法）
> 
>                                    |
> 
> 执行BeanPostProcessor的postProcessAfterInitialization()方法（Bean后置处理器再实例化之后执行）
> 
>                                    |
> 
> 执行InstantiationAwareBeanPostProcessor的postProcessAfterInitialization()方法（初始化感知后置处理器再实例化之后执行）

容器缓存阶段的主要作用就是把bean保存到容器以及spring的缓存中，到了这个阶段的bean就可以被开发者使用，这个阶段涉及到的操作，常见的像：init-method这个属性配置的一些方法会在这个阶段被调用以及BeanPostProcessors的后置处理方法。

五、销毁实例阶段

![](C:\Users\admin\AppData\Roaming\marktext\images\2022-08-11-15-24-29-image.png)

> 调用DiposibleBean的destory()方法
> 
> <mark>被BeanFactory调用，最终销毁单例对象</mark>
> 
>                         |
> 
> 调用Bean的destory-method方法（在配置中属性指定的方法）

当spring的应用上下文被关闭的时候，这个上下文中的所有的bean会被销毁，如果bean实现了DisposableBean接口或者配置了destory-method属性会在这个阶段被调用。

## spring支持的作用域

1. singleton：默认作用域，单例bean，每个容器中只有一个bean的实例。

2. prototype：每次请求都会为bean创建实例。

3. request：为每一个request请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。

4. session：与request范围类似，同一个session会话共享一个实例，不同会话使用不同的实例。

5. global-session：全局作用域，所有会话共享一个实例。如果想要声明让所有会话共享的存储变量的话，那么这全局变量需要存储在global-session中。

## spring框架中用到的设计模式

1. 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例。

2. 单例模式：Bean默认为单例模式。

3. 代理模式：spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。

4. 模板方法：用来解决代码重复的问题。比如RestTemplate、JmsTemplate、JpaTemplate。

5. 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如spring中listener的实现

## spring对象默认是单例的还是多例的？单例bean线程安全问题？

1. spring中对象默认是单例的，但是也可以配置为多例。

2. 单例bean对象对应的类存在可变的成员变量并且其中存在改变这个变量的线程时，多线程操作该bean对象时会出现线程安全问题。
   
   原因：多线程操作如果改变成员变量，其他线程无法访问该bean对象，造成数据混乱。
   
   解决办法：
   
   1.在bean对象中避免定义可变成员变量；
   
   2.在bean对象中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。

## spring事务的实现方式和实现原理

spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binLog或者redoLog实现的

<mark>binLog、redoLog是什么？</mark>

spring事务实现主要有两种方法：

1. 编程式，bginTransaction、commit、rollback等事务管理相关的方法。

2. 声明式，利用注解Transactional或者aop配置。

## spring常用注解

1. @Component、@Controller、@Service、@Repository：用于实例化对象

2. @Scope：设置spring对象的作用域

3. @PostConstruct：在spring容器启动时执行该方法、@PreDestroy：用于服务器卸载serviet时运行。

4. @Value：简单属性的依赖注入。

5. @Autowired：对象属性的依赖注入。

6. @Qualifier：要和@Autowired联合使用，代表在按照类型匹配的基础上再按照名称匹配。

7. @Resource：按照属性名称依赖注入。

8. @ComponentScan：组件扫描。

9. @Bean：标在方法上，用于将方法的返回值对象放入容器中。

10. @PropertySource：用于引入其他的properties配置文件。

11. @Import：导入其他类的内容。

12. @Configuration：被标注的类会被spring认为是配置类，在spring启动的时候会自动扫描并加载所有配置类，然后将配置类中bean放入容器。

13. @TransactionalL表示当前类中的方法具有事务管理功能。

## spring事务传播行为（propagation）

例子：有A方法，B方法两个方法，A调用B

- REQUIRED（required默认事务传播类型）：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。

- SUPPORTS：supports支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败），如果A中没有事务，那么B就以非事务方式运行（执行完直接提交）

- MANDATORY：mandatory支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败）；如果A中没有事务，B中有事务，那么B就直接抛异常了，意思是B必须要支持回滚的事务中运行。

- REQUIRES_NEW：requires_new创建新事务，无论当前存不存在事务，都创建新事务。B会新建一个事务，A和B事务互不干扰，他们出现问题回滚的时候，也都只回滚自己的事务。

- NOT_SUPPORTED：not_supported以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。被调用者B会以非事务方式运行（直接提交），如果当前有事务，也就是A中有事务，A会被挂起（不执行，等待B执行完，返回）；A和B出现异常需要回滚，互不影响。

- NEVER：never以非事务方式执行，如果当前存在事务，则跑出异常。就是B从不以事务方式运行 ；A中不能有事务，如果没有，B就以非事务方式执行，如果A存在事务，那么直接抛异常。

- NESTED：nested如此当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。如果A中没有事务，那么B创建一个事务执行，如果A中也有事务，那么B会会把事务嵌套在里面。

## spring隔离级别（ISOLATION）

1. DEFAULT：默认隔离级别，使用数据库默认的事务隔离级别。

2. READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。最低的隔离级别，会产生脏读、不可重复读和幻读。

3. READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。解决脏读问题。

4. REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新，行锁。解决脏读和不可重复读。

5. SERIALIZABLE：可串行化，一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。表锁。除了防止脏读，不可重复读外，还避免了幻像读。

### 概念说明

- 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问 这个数据，然后使用了这个未提交的数据。
  如：有两个事务A和B
  事务A通过where id =1，查询到age = 18，然后事务B同时去update这个id = 1 的数据 把age = 20，但是未提交
  此时事务A再次查询 id= 1时结果为age = 20，两次查询结果不一致。
  那么，这种在一个事务里面，由于其他的时候修改了数据并且没有提交，而导致了前后两次读取数据不一致的情况，这种事务并发的问题，我们把它定义成脏读。

- 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。
  如：有两个事务A和B
  事务A通过where id =1，查询到age = 18，然后事务B同时去update这个id = 1 的数据 把age = 20，已提交
  此时事务A再次查询 id= 1时结果为age = 20，两次查询结果不一致。
  这种第一个事务读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况，就像这里，age 到底是等于 16 还是 18，那么这种事务并发带来的问题，我们把它叫做不可重复读。(发生在update操作)。

- 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样
  如：有两个事务A和B
  事务A通过where age=18，查询到一条数据，然后事务B又新增了一条age = 18的数据
  此时事务A再次查询 age=18时，结果有两条数据，两次查询结果条数不一致。
  那么，一个事务前后两次读取数据数据不一致，是由于其他事务插入数据造成的，这种情况我们把它叫做幻读（发生在insert、delete操作）。

# springMVC

## springMVC主要组件

- 前端控制器 DispatchServlet：接收请求、响应结果，相当于转发器，有了DispatcherServlet就减少了其他组件之间的耦合度。

- 处理器映射器 HandlerMapping：根据请求的URL来查找Handler。

- 处理器适配器 HandlerAdapter：负责执行Handler。

- 处理器Handler：处理业务逻辑的java类。

- 视图解析器 ViewResolver：进行视图的解析，根据视图逻辑名将ModelAndView解析成真正的视图（view）。

- 视图View：View是一个接口，它的实现类支持不同的视图类型，如jsp，freemarker，pdf等等。  

## springMVC的执行流程以及各个组件的作用

1. 用户发送请求到前端控制器（DispatcherServlet）

2. 前端控制器（DispatchServlet）收到请求调用处理器映射器（HandlerMapping），去查找处理器（Handler）。

3. 处理器映射器（HandlerMapping）找到具体的处理器（可以根据xml、注解进行查找），生成处理器对象以及处理拦截器（如果有则生成）一并返回给DispatcherServlet。

4. 前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行Handler。

5. Handler执行完成给适配器返回ModelAndView，ModelAndView是springmvc框架的一个底层对象，包括Model和view。

6. 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)。

7. 视图解析器向前端控制器返回View。

8. 前端控制器进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域。

9. 前端控制器向用户响应结果。

## springMVC统一异常处理

- 方法一：创建一个自定义异常处理器（实现HandlerExceptionResolver接口），并实现里面的异常处理方法，然后将这个类交给spring容器管理。

- 方法二：在类上加注解（@ControllerAdvice）表名这是一个全局异常处理类；在方法上加注解（@ExceptionHandler），在ExceptionHandler中有一个value属性，可以指定可以处理的异常类型。  

# springboot

## springboot启动器starter

1. 什么是starter：starter启动器，可以通过启动器集成其他的技术，比如web，mybatis，redis等等，可以提供对应技术的开发和运行环境。

2. starter执行原理：一、springboot在启动的时候会去扫描jar包中的一个名为spring.factories。二、根据文件中的配置，去加载自动配置类。配置文件格式是key=value，value中配置了很多需要spring加载的类。三、spring会去加载这些自动配置类，spring读取后，就会创建这些类的对象，放到spring容器中，后期就会从spring容器中获取这类对象。

3. springboot中常用的启动器：spring-boot-starter-web，提供web技术支持；spring-boot-starter-test；spring-boot-starter-jdbc；spring-boot-starter-jpa；spring-boot-starter-redis等等。

## springboot自动装配

### 注解

1. @SpringBootConfiguration：其本质是@Configuration，定义该类是一个配置类，功能等同于xml配置文件。@Configuration和@Bean两个注解可以创建一个简单的Spring配置类，可以用来替代相应的xml配置文件，可以理解为创建了IOC容器。

2. @EnableAutoConfiguration：其本质就是@import导入所有符合自动配置条件的bean定义加载到ioc容器。@EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置。

### 如何完成自动配置

主要注解为@EnableAutoConfiguration。

注解内部使用的@Import，导入了AutoConfigurationImportSelector类，这类内部提供了一个方法selectImports，这个方法会扫描导入的所有jar包下的spring.factories文件，解析其中的key=value，将列表中的类创建，并放到Spring容器中。

# mybatis

## ${}和#{}的区别

${}是字符替换，mybatis在处理时，直接替换成变量的值；

#{}是占位符，预编译处理，mybatis在处理时，会将sql中的#{}替换为？号，调用PreparedStatement的set方法来赋值；

## resultType和ResultMap的区别

如果数据库结果集中的列名和要封装实体的属性名完全一致的话用resultType；

如果数据库结果集中的列名和要封装实体的属性名有不一致的情况用resultMap属性，通过resultMap手动建立对象关系映射，resultMap要配置一下表和类的一一对应关系。

## mybatis缓存机制

mybatis有两级缓存，一级缓存是SqlSession级别的，默认开启，无法关闭；二级缓存是Mapper级别的，二级缓存默认是没有开启的但是手动开启。

1. 一级缓存：基础PerpetualCache的HashMap本地缓存，其存储作用域为session，当session flush或close之后，session中的所有cache就将清空。

2. 二级缓存其存储作用域为Mapper，使用二级缓存属性类需要实现serializable序列化接口。

3. 对于缓存数据更新机制，当某一个作用域(一级缓存session/二级缓存namespaces)的进行了crud操作后，默认该作用域下所有select中的缓存将被clear。

# Redis

## redis的存储结构

- String，字符串类型，一个key对应一个value。

- Hash，散列，是一个键值（key=>value）对集合。string类型的field和value的映射表，特别适合用于存储对象。

- List，列表，是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列边或者尾部。

- Set，集合，是string类型的无序集合。

- Sorted set，有序集合，和set一样也是string类型的元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数却可以重复。

## redis适合的场景

1. 会话缓存

2. 全页缓存

3. 队列

4. 排行榜/计数器

5. 发布/订阅

## redis的优点

1. 因为是纯内存操作，redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的key-value数据库。redis支持事务、持久化。

2. 多线程操作，避免了频繁的上下文切换。

3. 采用了飞阻塞I/O多路复用机制。I/O多路复用就是只有单个线程，通过跟踪每个I/O流的状态，来管理多个I/O流。

# redis的缺点

### 缓存和数据库双写一致性问题

解决方案：

1. 编写删除缓存的接口，在更新数据库的同时，调用删除缓存的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。

2. 消息队列：activeMq，消息通知

### 缓存的并发竞争问题

解决方案：

1. 最简单的方式就是准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。

### 缓存雪崩问题

即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都去查询数据库，从而导致数据库连接异常。

解决方案：

1. 给缓存的失效时间加上一个随机值，避免集体失效。

2. 使用互斥锁，但是该方案的吞吐量明显下降了。

3. 搭建redis集群。

4. 设置过期标志更新缓存：当缓存过期则通知线程后台更新

### 缓存击穿

即黑客故意请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

解决方案：

1. 利用互斥锁，缓存失效的时候就先去获得锁，得到锁了，再去请求数据库，没得到锁则休眠一段时间重试。

2. 采用异步更新策略，无论key是否取到值，都直接返回，value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库更新缓存。

## redis的持久化

redis提供两种持久化方法，分别是RDB和AOF

1. RDB：就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上。redis会单独创建一个子进程（使用fork函数）来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作，这就确保了极高的性能。

2. AOF：将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。持久化过程：一、客户端请求写命令会被append追加到AOF缓冲区。二、AOF缓冲区根据AOF持久化策略【always，everysec，no】将操作sync同步到磁盘的AOF文件中。三、AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。四、redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复目的。

## RDB和AOF优缺点

### RDB优点

1. RDB是一个非常紧凑的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。

2. 生成RDB文件的时候，redis主进程会fork一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。

3. RDB在恢复大数据集时的速度比AOF的恢复速度要快。

### RDB缺点

1. RDB方式数据没办法做到实时持久化或秒级持久化因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。

2. RDB文件使用特点二进制格式保存，redis版本演进过程中有多个格式的RDB版本，存在老版本redis服务无法兼容新版RDB格式的问题（版本不兼容）。

3. 在一定间隔时间做一次备份，如果redis意外down掉，就会丢失最后一次快照后的所有修改。

### AOF优点

1. 备份机制更稳健，丢失数据概率更低。

2. 可读的日志文本，考验处理误操作。

### AOF缺点

1. 比起EDB占用更多的磁盘空间。

2. 恢复备份速度要慢。

3. 每次读写都同步的话，有一定的性能压力。

4. 存在个别bug，造成恢复不能。

## redis分布式锁

### 单体应用

对并发操作进行加锁操作，保证对数据的操作具有原子性

- synchronized

- ReentrantLock

### 分布式应用

方案一：使用set命令：set key value [EX seconds] [PX milliseconds] [NX|XX]

> EX seconds ——设置指定的到期时间（以秒为单位）
> 
> PX milliseconds——设置指定的到期时间（以毫秒为单位）
> 
> NX——仅在键不存在时设置键
> 
> XX——只有键存在时才设置

方案二：setnx+exprie

方案三：setnx+value（系统时间+过期时间）

方案四：使用lua脚本

方案五：Redisson开源框架

方案六：RedLock

## redis单线程还是多线程

redis5之前是单线程，指的是工作线程为单线程。工作机制：读IO流、计算（把数据插入内存）、writeIO（返回结果）。

### 理解

一次完整的redis请求事件有多个阶段（客户端到服务器的网络连接--->redis读写事件发生--->redis服务端的数据处理（单线程）--->数据返回）。平时所说的redis单线程模型，本质上指的是服务端的数据处理阶段，不牵扯网络连接和数据返回。

1. 客户端到服务器的网络连接：客户端和服务器是socket通信方式，socket服务端监听可同时接受多个客户端请求，这里与redis无关，仅仅做网络连接。

2. redis读写事件发生并向服务端发送请求：redis的客户端与服务端通信是基于TCP连接，完成上一个阶段的网络连接，redis客户端开始真正向服务器发起读写事件，此时redis客户端开始向建立的网络流中推送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。

3. redis服务端的数据处理：服务端完成第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。

4. 数据返回

## IO多路复用

# rabbitmq

## 为什么要用rabbitmq

1. 在分布式系统下具备异步，削峰，负载均衡等一系列高级功能。

2. 拥有持久化的机制，进程消息，队列中的信息也可以保存下来。

3. 实现消费者和生产者之间的解耦。

4. 对于高并发场景下，利用消息队列可以使得同步访问变为串行访问，达到一定量的限流，利于数据库的操作。

5. 可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。

## 使用rabbitmq的场景

1. 服务间异步通信

2. 顺序消费

3. 定时任务

4. 请求削峰

## 如何确保消息正确地发送至rabbitmq？如何确保消息接收方消费了消息？

发送方确认模式：

> 将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。
> 
> 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化消息），信道会发送一个确认给生产者（包含消息唯一ID）。
> 
> 如果rabbitmq发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。

接收发确认机制：

> 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同的操作）。只有消费者确认了消息，rabbitmq才能安全地从队列中删除。
> 
> 这里并没有用到超时机制，rabbitmq仅通过Consumer的连接终端来确认是否需要重新发送消息。也就是说，只要连接不中断，rabbitmq给了Consumer足够长的时间来处理消息。保证数据的最终一致性。
> 
> 下面罗列几种特殊情况：
> 
> 1. 如果消费接收到消息，在确认之前就断开了连接或取消订阅，rabbitmq会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）。
> 
> 2. 如果消费者接收到消息却没有确认消息，连接也未断开，则rabbitmq认为该消费者繁忙，将不会给该消费者分发更多的消息。

## 如何避免消息重复投递或者重复消费

在消息生成时，mq内部针对每条生产者发送的消息生成一个inner-msg-id。作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体重必须要有一个bizId（对于统一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重的依据，避免同一条消息被重复消费。

## 消息基于什么传输

由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。rabbitmq使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。

## 消息如何分发

若该队列至少有一个消费者订阅，消息将以循环的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能。

## 消息怎么路由

消息提供方--->路由--->一至多个队列消息发布到交换器时，消息将拥有一个路由键，在消息创建时设定。通过队列路由键，可以吧队列绑定到交换器上。消息到达交换器后，rabbitmq会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；

常用的交换器主要分为以下三种：

> - fanout：如果交换器收到消息，将会广播到所有绑定的队列上
> 
> - direct：如果路由键完全匹配，消息就被投递到相应的队列
> 
> - topic：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符。

## 如何确保消息不丢失

消息持久化，前提是队列必须持久化。

rabbitmq确保持久性消息能从服务器中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，rabbitmq会在消息提交到日志文件后才发送响应。一旦消费者从持久化队列中消费了一条持久化消息，rabbitmq会在持久化日志中吧这条消息标记为等待垃圾收集。如果持久化消息在背消费之前rabbitmq重启，那么rabbitmq会自动重建交换器和队列（以及绑定），并重新发布持久化日志稳重的消息到合适的队列。

## mq的缺点

1. 系统可用性降低

2. 系统复杂性提高

3. 一致性问题

# mysql

## 存储引擎

MyISAM存储引擎 

> 特点是不支持事务、外键、表锁和全文索引，拥有较高的插入、查询速度。
> 
> 每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD（MYData，存储数据）、.MYI（MYIndex，存储索引）。这里特别要注意的是MyISAM不缓存数据文件，值缓存索引文件。

InnoDB存储引擎

> InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行所和外键，是mysql默认引擎。

两种存储引擎的区别。

1. InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。

2. MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。

3. InnoDB支持外键，MyISAM不支持。

4. MySQL 在 5.1 之前版本默认存储引擎是 MyISAM，5.1 之后版本默认存储引擎是 InnoDB。

5. InnoDB不支持FULLTEXT类型的索引。

6. InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。

7. 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。

8. 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。

9. InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'。

## 数据库事务

### 事务特性

原子性（Atomicity）：即不可分割性，事务要么全部被执行，要么就全部不被执行。

一致性（Correspondence）：事务的执行使得数据库从一种正确状态转换成另一种正确状态。

隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的如何改变提供给任何其他事务。

持久性（Durability）：事务正确提交后，其结果见永久保存在数据库中，即使事务提交后有了其他故障，事务的处理结果也会得到保存。

### 隔离级别

1、读未提交（read Uncommited）：

在该隔离级别，所有的事务都可以读取到别的事务中为提交的数据，会产生脏读问题。

2、读已提交（read commited）：

这是大多数数据库默认的隔离级别，但不是mysql的默认隔离级别；这个隔离级别满足了简单的隔离要求：一个事务只能看见以及提交事务所做的改变，所以会避免脏读问题；

由于一个事务可以看到别的事务以及提交的数据，于是随之而来产生了不可重复读和虚读等问题。

3、可重复读（Repeatable read）：

这是mysql的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上这会导致另一个棘手的问题：幻读（Phantom Read）。指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户在读取该范围的数据行时，会发现有新的”幻影“行，InnoDB和Falcon存储引擎通过多版本并发控制（MVCC）机制解决了该问题。

4、可串行化（serializable）：

事务的最高级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

## 索引

索引存储在内存中，为服务器存储引擎为了快速找到记录的一种数据结构。索引的主要作用是加快数据查找速度，提高数据库的性能。

## 索引的分类

1. 普通索引：最基本的索引，没有任何限制。

2. 唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

3. 主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key来约束。

4. 联合索引（符合索引）：多个字段上建立的索引，能够加速符合查询条件的检索。

5. 全文索引：不支持中文全文检索，可以通过扩展MySQL，添加中文全文检索或为中文内容表提供一个对应的英文索引表的方式来支持中文。

## B树

B树特点：

1. 节点排序

2. 一个节点可以存多个元素，多个元素也排序了

## B+树

B+树特点：

1. 拥有B树的特点

2. 叶子节点之间有指针（支持范围查找）

3. 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了多有所有的元素，并且排序了。

B+树的非叶子节点不存储数据，而是存索引数据，每个叶子节点都是存key、value

## 为什么mysql使用B+树

MySQL索引使用的是B+树，因为索引使用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在mysql中一个InnoDB页就是一个B+树节点，一个InnoDB页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等sql语句。

> 1、B+树 更便于范围查询
> 
> 因为B+树只需要去遍历叶子节点就可以实现整棵树的遍历，而B树则需要通过从根节点从上往下的遍历。
> 
> 2、B+树的读写磁盘代价更低
> 
> 因为B+树的每个非叶子节点存储都是数据索引，而不是数据本身，那么每块数据(也就是和每个节点)存储的索引更多，加载到内存，查询也更多，也就是说IO读写次数也就降低了。
> 
> 3、 B+树查询效率更加稳定
> 
> 由于B+树的数据或者数据引用都是存储到叶子节点的，每次的查询都是从根节点到叶子节点的路程，查询的路径长度相同，导致每一个数据的查询效率相当；

## mysql索引优化

（1）最左前缀法则

> 如果建立的是复合索引，索引的顺序要按照建立时的顺序 ，即从左到右，如：a->b->c

（2）不要对索引做以下处理

> - 计算，如：+、-、*、/、!=、<>、is null、is not null、or
> 
> - 函数，如：sun()、round()等等
> 
> - 手动/自动类型转换，如：id="1"，不来是数字，给写成了字符串

（3）索引不要放在范围查询右边

> 比如复合索引：a->b->c，当where a="" and b>10 and 3="" ，这时候只能用到a和b，c用不到索引，因为在范围之后索引都失效

（4）减少select*的使用

> 即：select查询字段和where中使用的索引字段一致

（5）like模糊查询

失效情况

> - like “%张三%”
> 
> - like “%张三”

解决方案

> - 使用覆盖索引，即like字段是select的查询字段，如：select name from table where name like “%张三%”
> 
> - 使用like “张三%”

（6）order by优化

当查询语句中使用order by 进行排序时，如果没有使用索引进行排序，会出现filesort文件内排序，这种欠款在数据量大或者并发高的时候，会有性能问题，需要优化。

filesort出现的情况举例

> - order by字段不是索引字段
> 
> - order by字段是索引字段，但是select中没有使用覆盖索引，如：select* from table order by age asc；
> 
> - order by中同时存在asc升序排序和desc降序排序，如：select a，b from table order by a desc，b asc；
> 
> - order by多个字段排序时，不是按照索引顺序进行order by，即不是按照最左前缀法则，如：select a,b from table order by b asc ，a asc；

索引层面解决方法

> - 使用主键索引排序
> 
> - 按照最左前缀法则，并且使用覆盖索引排序，多个字段排序时，保持排序方向一致
> 
> - 在 SQL 语句中强制指定使用某索引，force index(索引名字)
> 
> - 不在数据库中排序，在代码层面排序

（7）group by优化

其原理也是先排序后分组，其优化方式可参考order by。where高于having,能写在where限定的条件就不要去having限定了。

# Nginx

nginx是一个高性能的http和反向代理服务器，以及电子邮件代理服务器，同时也是一个非常高校的反向代理、负载平衡。

## Nginx的作用

1. 反向代理：将多台服务器代理成一台服务器。

2. 负载均衡：将多个请求均匀的分配到多台服务器上，减轻每台服务器的压力，提高服务的吞吐量。

3. 动静分离：Nginx可以用作静态文件的缓存服务器，提高访问速度。

## 反向代理

反向代理是指以代理服务器来接受internet上的连接请求，然后将请求，发给内部网络上的服务器，并将服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

代理端代理的是服务器。

## 正向代理

一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。

代理端代理的是客户端。

## 负载均衡

负载均衡是代理服务器将接收的请求均衡的分发到各服务器中，负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力。

## Nginx如何处理一个请求

1. 首先，Nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在Nginx的master进程里面先初始化好这个监控的socket，再进行listen，然后再fork出多个子进程出来，子进程会竞争accept新的连接。

2. 此时客户端就可以向Nginx发起连接，当客户端与Nginx进行三次握手，与Nginx建立好一个连接后，此时，某一个子进程会accept成功，然后创建Nginx对连接的封装，即ngx_connection_t结构体，接着，根据事件调用相应的事件处理模块，如http模块与客户端进行数据的交换。

3. 最后，Nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了。

# JWT

- JSON Web token简称JWT，是用于对应用程序上的用户进行身份验证的标记，也就是说，使用JWTS的应用程序不再需要保存有关其用户的cookie或session数据。此特性便于可伸缩性，同时保证应用程序的安全。

- 在身份验证过程中，当用户使用其凭据成功登陆时，将返回JSON Web token，并且必须在本地保存（通常在本地存储中）。

- 每当用户要访问受保护的路由或资源（端点）时，用户代理（user agent）必须连同请求一起发送JWT，通常在授权标头中使用Bearer schema。后端服务器接收到带有JWT的请求时，首先要做的是验证token。

# 组成

一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。

头部（Header）

> 头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。
> 
> {“type”：“JWT”，“alg”：“HS256”}
> 
> 在头部指明了签名的算法是HS256算法。

载荷（playload）

载荷就是存放有效信息的地方。这些有效信息包含三个部分

> 1、标准中注册的声明
> 
> - iss：jwt签发者
> 
> - sub：jwt所面向的用户
> 
> - aud：接收jwt的一方
> 
> - exp：jwt的过期时间，这个过期时间必须要大于签发时间
> 
> - nbf：定义在什么时间之前，该jwt都是不可用的
> 
> - iat：jwt的签发时间
> 
> - jti：jwt的唯一身份标识，主要用来作为一次性token
> 
> 2、公共的声明
> 
> 公共的声明可以添加任何的信息，一般添加用户的相关信息过其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。
> 
> 3、私有的声明
> 
> 私有声明式提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，以为这该部分信息可以归类为明文信息。

签证（signature）

jwt 的第三部分是一个签证信息，这个签证信息由三部分组成：

header (base64 后的)
payload (base64 后的)
secret

这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成
的字符串，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了
jwt

### 注意

secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行
jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。

# Http协议

## 什么是http协议

客户端和服务器端之间数据传输的格式规范，简称为超文本传输协议。是一个基于请求与响应模式的、无状态的、应用层的协议，基于TCP的连接方式。

## http长连接和短连接

http协议有http1.0版本和http1.1版本。

http1.1默认保持长连接，数据传输完成后保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。

在http1.0中默认使用的是短连接。也就是说，浏览器和服务器每进行一次http操作，就建立一次连接，任务结束就中断连接。从http1.1起默认使用的是长连接，用以保持连接特性。

## HTTP1.1与HTTP1.0的区别

1、可扩展性

> - http1.1在消息中增加版本号，用于兼容性判断
> 
> - http1.1增加了options方法，它允许客户端获取一个服务器支持的方法列表
> 
> - 为了与未来的协议规范兼容，http1.1在请求消息中包含了upgrade头域，通过该头域，客户端可以让服务器知道它能够支持的其他备用通信协议，服务器可以据此进行协议切换，使用备用协议与客户端进行通信。

2、缓存

> 在http1.0中，使用expire头域来判断资源的fresh或stale，并使用条件请求来判断资源是否仍有效。http1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的age超过expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活

3、带宽优化

> http1.0中，存在一些浪费带宽的现象，例客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，例如：客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。
> 
> http1.1中在请求消息中引入了range头域，它允许值请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应的返回了对象所请求范围的内容，则响应码为206，它可以防止cache将响应误以为是完整的一个对象。
> 
> 另外一中情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。
> 
> http1.1加入了一个新的状态码100,。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，http1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入expect头域，并将它的值设置为100-continue。
> 
> 节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端的编码，它可能是资源在服务器上保存的固有格式；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。

4、长连接

> http1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。
> 
> http1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。
> 
> http1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序一次回送响应结果，以保证能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

5、消息传递

> http消息中可以包含任意长度的实体，通常它们使用Content-Length来给出消息结束标志。但是，对于很多动态产生的响应，只能通过缓冲完整的消息来判断消息的大小，但这样做会加大延迟。如果不使用长连接，还可以通过连接关闭的信号来判定一个消息的结束。
> 
> http1.1中一如了chunkedtransfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
> 
> 在http1.0中，有一个Content-MD5的头域，要计算这个头域需要发送方缓冲完整个消息后才能进行。而http1.1中，采用chunked分块传递的消息在最后一个块（零长度）结束之后会再传递一个拖尾，它包含一个或多个头域，这些头域是发送方在传递完所有块之后再计算出值的，发送方会在消息中包含一个Trailer头域告诉接收方这个拖尾的存在。

6、Host头域

> 在http1.0中认为每台服务器都绑定一个唯一的ip地址，因此，请求消息中的URL并没有传递主机名。但随着虚拟主机的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个ip地址。
> 
> http1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400）。此外，服务器应该接受以绝对路径标记的资源请求。

7、错误提示

> http1.0中只定义了16个状态响应码，对错误或警告的提示不够具体。http1.1引入了一个warning头域，增加对错误或警告信息的描述。
> 
> 此外，在http1.1中新增了24个状态响应码，如409表示请求的资源与资源的当前状态发生冲突；410表示服务器上的某个资源被永久性的删除。

## http常见的状态码

- 200：ok客户端请求成功

- 301：Moved Permanently（永久移除），请求的URL已移走。Response中应该包含一个Location URL，说明资源现在所处的位置

- 302：found 重定向

- 400：Bad Request，客户端请求有语法错误，不能被服务器所理解

- 401：Unauthorized，请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用

- 403：Forbidden，服务器收到请求，但是拒绝提供服务

- 404：Not Found，请求资源不存在，eg：输入了错误的URL

- 500：Internal Server Error，服务器发生不可预期的错误

- 503：Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能恢复正常

## GET和POST的区别

1. get请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&相连。POST把提交的数据则放置在HTTP包的包体中。

2. GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据。其实：GET可提交的数据量跟URL的长度有直接关系。实际上URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节。对于其他浏览器理论上没有长度限制，其限制取决于操作系统的支持。

3. POST的安全性比GET高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，使用GET提交数据还可能会造成Cross-site request forgery攻击。

GET是向服务器发索取数据的一种请求，而POST是向服务器提交数据的一种请求，在FORM（表单中），Method默认为“GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发。

# TCP与UDP区别

TCP（传输控制协议）是一种面向连接（连接导向）的、可靠的、基于ip的传输层协议。

UDP是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

TCP和UDP都是来自于传输层的协议。传输层位于应用层和网络层之间，负责位于不同主机中进程之间的通信。

区别

> 1. TCP基于连接，UDP无连接
> 
> 2. TCP要求系统资源较多，UDP较少
> 
> 3. TCP保证数据正确性，UDP可能丢包
> 
> 4. TCP保证数据顺序，UDP不保证

# TCP的三次握手

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。三次握手的目的是建立可靠的通信信道（通信就是数据的发送与接收），而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

SYN：同步序列标号。是TCP/IP建立连接时使用的握手信号。

> 第一次：客户端-->服务器，发送标有SYN的数据包
> 
> 第二次：服务器-->客户端，确认收到，并发送SYN/ACK数据包
> 
> 第三次：客户端-->服务器，确认消息（发送标有ACK的数据包）

第一次握手：客户端给服务器发送一个SYN。客户端发送网络包，服务端收到了，服务器得出结论：客户端的发送能力，服务端的接收能力正常。

第二次握手：服务端收到SYN报文之后，会应答一个SYN+ACK报文。服务端发包，客户端收到了。客户端得出结论：服务端的接收和发送能力，客户端的接收和发送能力正常。但是此时服务端不能确认客户端的接收能力是否正常。

第三次握手：客户端收到SYN+ACK报文之后，回应一个ACK报文。客户端发包，服务端收到了。服务器得出结论：客户端的接收和发送能力，自己的接收发送能力都正常。

通过三次握手，双方都确认对方的接收以及发送能力正常。

# 多线程

## 创建线程的几种方式

1. 继承Thread类并重写run方法创建线程，实现简单但不可以继承其他类。

2. 实现Runnable接口并重写run方法。避免了单继承局限性，编程更加灵活，实现解耦。

3. 实现Callable接口并重写call方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。

4. 使用线程池创建（使用java.util.concurrent.Executor接口）

## Runnable和Callable的区别

- Runnable接口run方法无返回值；Callable接口call方法有返回值，支持泛型

- Runnable接口run方法只能抛出运行时异常，且无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息

## 如何启动一个新线程，调用start和run方法的区别

- 线程对象调用run方法不开启线程。仅是对象调用方法。

- 线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。

- 调用start方法可以启动线程，并且使得线程进入就绪状态，而run方法只是thread的一个普通方法，还是在主线程中执行。

## 线程有哪几种状态以及各状态之间的转换

![](F:\zheng\MarkText\image\2022-08-19-16-22-11-image.png)

1. 第一是new-->新建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。

2. 第二是Runnable-->就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没把该线程设置为当前线程，此时处于就绪状态。

3. 第三是Running-->运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。

4. 第四是阻塞状态。阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。知道线程进入就绪状态，才有机会转到运行状态。阻塞状态的情况分三种：
   
   1. 等待：通过调用线程的wait方法，让线程等待某工作的完成。
   
   2. 超时等待：通过调用线程的sleep或join或发出了IO请求时，线程会进入阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者IO处理完毕时，线程重新转入就绪状态。
   
   3. 同步阻塞：线程在获取synchronized同步所失败（因为所被其他线程所占用），它会进入同步阻塞状。

5. 第五是dead-->死亡状态。线程执行完了或者因异常退出了run方法，该线程结束生命周期。

## 线程相关的基本方法

wait、notify、notifyAll、sleep、join、yield、interrupt

### 线程等待（wait）

调用该方法的线程进入waiting状态，只有等待另外线程的通知或被终端才会返回，需要注意的是调用wait方法后，会是否对象的锁。因此，wait方法一般用在同步方法或同步代码块中。

### 线程睡眠（sleep）

sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁，sleep（long）会导致线程进入timed-wating状态，而wait方法会导致当前线程进入wating状态。

### 线程让步（yield）

yield会使当前线程让出CPU执行时间片，让其他线程一起重新竞争CPU时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程的优先级并不敏感。

### 线程中断（interrupt）

中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态（如阻塞，终止等）

### join等待其他线程终止

join方法，等待其他线程终止，在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待cpu。

### 线程唤醒（notify）

Object类中的notify方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有notifyAll，唤醒在此监视器上等待的所有线程。

## wait和sleep的区别

1. 来自不同类：wait来自Object类，sleep来自Thread类。

2. 锁的释放：wait在等待过程中会释放锁，sleep不会释放锁。

3. 使用的范围：wait必须在同步代码块中使用，sleep可以在任何地方使用。

4. 捕获异常：waitl不需要捕获异常，sleep需要捕获异常。

## 线程互斥和同步

在引入多线程后，由于线程执行的异步性，会给系统造成混乱，特别是在急用临界资源时，如多个线程急用同一台打印机，会使打印结果交织在一起，难以区分。当多个线程急用共享变量，表格，链表时，可能会导致数据处理出错，一次线程同步的主要任务是使并发执行的各线程之间能够有效共享资源和相互合作，从而使程序的执行具有可再现性。

当线程并发执行时，由于资源共享和线程协作，使用线程之间会存在以下两种制约关系。

1. 间接相互制约。一个系统中的多个线程必然要共享某种系统资源，如共享CPU，共享IO设备，所谓间接相互制约即源于这种资源共享，打印机就是最好的例子，线程A在使用打印机时，其他线程都要等待。

2. 直接相互制约。这种制约主要是因为线程之间的合作，如有线程A将技术结果提供给线程B作进一步处理，那么线程B在线程A将数据送达之前都将处于阻塞状态。

间接相互制约可以称为互斥，直接相互可以称为同步，对于互斥可以这样理解，线程A和线程B互斥访问某个资源则它们之间就会产生顺序问题——要么线程A等待线程B操作完毕，要么线程B等待线程A操作完毕，这就是线程的同步。一次同步包括互斥，互斥是一种特殊的同步

## synchornized

- 修饰非静态方法时，作用于当前对象。

- 修饰静态方法时，作用于当前类。

## 线程局部变量ThreadLocal

ThreadLocal的作用和目的：用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。

### ThreadLocal与Synchronized的区别

1. synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。

2. Synchronized是利于锁的机制，使变量或代码在某一时刻只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。

### ThreadLocal常见使用场景

1. 存储用户Session

2. 数据库连接，处理数据库事务

3. 数据跨层传递

4. Spring使用ThreadLocal解决线程安全问题

# 线程池

## 线程池的分类

1. newCachedThreadPool：创建一个可进行缓存重复利用的线程池

2. newFixedThreadPool：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量

3. newSingleThreadExecutor：创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。线程池中最多执行一个线程，之后提交的线程将会排在队列中依次执行

4. newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期执行

5. newScheduledThreadPool：创建一个线程池，它可安排在给定延迟后运行命令或或者定期的执行

6. newWorkStealingPool：创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行，如不传并行级别参数，将默认为当前系统的CPU个数

7. ThreadPoolExecutor：手动创建线程池，可自定义相关参数

## 核心参数

- corePoolSize：核心线程池的大小

- maximumPoolSize：线程池能创建线程的最大个数

- keepAliveTime：空闲线程存活时间

- unit：时间单位

- workQueue：阻塞队列，用于保存任务的阻塞队列

- threadFactory：创建线程的工程类

- handler：饱和策略（拒绝策略）  

## 线程池原理

![](G:\zheng\MarkText\image\2022-08-22-16-57-08-image.png)

线程池的工作过程如下：

当一个任务提交至线程池之后

1. 线程池首先判断核心线程池里的线程是否以及满足了。如果不是，则创建一个新的工作线程来执行任务。否则进入2。

2. 判断工作队列是否以及满了，倘若还没有满，将线程放入工作队列。否则进入3。

3. 判断线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行。如果线程池满了，则交给饱和策略来处理任务。

### 饱和策略（拒绝策略）

ThreadPoolExecutor.AbortPolicy（系统默认）：丢弃任务并抛出RejectedExcutionException异常，让你感知到任务被拒绝了，我们可以根据业务逻辑选择重试或者放弃提交等策略

ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常，相对而言存在一定风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。

ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复次过程），通常是存活时间最长的任务，它也存在一定的数据丢失风险。

ThreadPoolExecutor.CallerRunsPolicy：即不抛弃任务也不抛出异常，而是将某些任务回退到调用者，让调用者去执行它。

## 线程池的关闭

关闭线程池可以通过shutdown和shutdownNow两个方法

原理：遍历线程池中的所有线程，然后一次中断

1. shutdownNow首先将线程池的状态设置为stop，然后尝试停止所有的正在执行和未执行的线程，并返回等待执行任务的列表；

2. shutdown此方法关闭线程池不是直接关闭，需要等待线程池中的正在执行的和在队列中的任务都执行完毕后，才真正关闭线程池，调用这个方法后，如果再对线程池提交任务，会根据拒绝策略来拒绝任务。

## 线程池的状态判断

1. isShutdown此方法在线程已经开始关闭的时候返回true，其他时候返回false，即是否调用了线程池的shutdown或shutdownnow方法，返回true不代表线程池已经终止了，还有可能是需要线程池需要等待正在执行的任务或任务队列中的任务执行完。

2. isTerminated此方法返回true表示线程池的所有任务都执行完毕了，线程池终结了；如果线程池调用了shutdown，但是任务还没执行完，`isShutdown`返回true，而`isTerminated`返回false。

## 线程池中几个实现类

1. ExecutorService真正的线程池接口。

2. ScheduledExecutor，解决那些需要任务重复执行的问题。

3. ThreadPoolExecutor，ExecutorService的默认实现。

4. ScheduledThreadPoolExecutor继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。

# JVM

JDK1.8的JVM运行时内存（内存划分）

JVM虚拟机数据区

> 程序计数器、本地方法栈、堆、java虚拟机栈

本地内存

> 元数据区、直接内存

- 程序计数器：线程私有的（每个线程都有一个自己的程序计数器），是一个指针。代码运行，执行命令。而每个命令都是由行号的，会使用程序计数器来记录命令执行到多少行了。记录代码执行的位置。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

- Java虚拟机栈：线程私有的（每个线程都有一个自己的Java虚拟机栈）。一个方法运行，就会给这个方法创建一个栈帧，栈帧入栈执行代码，执行完毕之后出栈（弹栈）存引用变量，基本数据类型。

- 本地方法栈：线程私有的（每个线程都有一个自己的本地方法栈），和java虚拟机栈类似，java虚拟机栈加载的是普通方法，本地方法加载的是native修饰的方法。native：在java中有用native修饰的，表示这个方法不是java原生的。

- 堆：线程共享的（所有线程共享一份）。存放对象的，new的对象都存储在这个区域。还有就是常量池。

- 元空间：存储.class信息，类的信息，方法的定义，静态变量等。而常量池放到对立面存储。

> jdk1.8永久代转换成元空间的原因：
> 
> 1. 字符串存在永久代中，容易出现性能问题和内存移除
> 
> 2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代移除，太大则容易导致老年代溢出
> 
> 3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低 

## jdk1.8堆内存结构

![](G:\zheng\MarkText\image\2022-08-22-21-12-28-image.png)

jdk1.8永久代的对象放到了元数据区，不存永久代这一区域

- 年轻代：Eden+S0+S1，S0和S1大小相等，新创建的对象都在年轻代

> 所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。
> 
> 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。
> 
> 2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
> 
> 针对年轻代的垃圾回收即Young GC

- 年老代：结果年轻代多次垃圾回收存活下来的对象存在年老代中

> 在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
> 
> 针对年老代的垃圾回收即Full GC

## 对象生成时，内存的申请过程

1. JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。

2. 当Eden区空间足够时，内存申请结束。否则执行下一步。

3. JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。

4. Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。

5. 当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。

6. Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。

### **OOM（“Outof Memory”）异常**

- 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace
  
  > 这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。
  > 
  > 例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。

- 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace
  
  > 通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcatshare lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。

## GC垃圾回收

jvm的垃圾回收动作可以大致分为两大步，首先是【如何发现垃圾】，然后是【如何回收垃圾】。说明一点，线程私有的不存在垃圾回收，只有线程共享的才会存在垃圾回收，所以堆中存在垃圾回收。

#### 如何发现垃圾

常见的用于【发现垃圾】的算法有两种，引用计数算法和根搜索算法

1、引用计数算法

        堆中的对象每被引用一次，则计数器加1，没减少一个引用就减1，当对象的引用计数器为0时可以被当做垃圾收集。

        优点：快

        缺点：无法检测出循环引用，如两个对象相互引用时，他们的引用计数永远不为0

2、根搜索算法（可达性分析）

        根搜索算法是把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即可以当做垃圾。

        java中可作为GC Root的对象有：

1. 虚拟机栈中引用的对象

2. 本地方法栈引用的对象

3. 方法区中静态属性引用的对象

4. 方法区中常量引用的对象 

### 如何回收垃圾（垃圾回收算法）

java中用于【回收垃圾】的常见算法有4种：

1、标记-清除算法

分为”标记“和”清除“两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

缺点：首先，效率问题，标记和清除效率都不高。其次，标记清除之后会产生大量的不连续的内存碎片。

2、标记-整理算法

是在标记-清除算法基础上做了改进，标记阶段是相同的，但标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。

优点：内存被整理后不会产生大量不连续内存碎片。

3、复制算法

将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上，，然后把使用过的内存空间一次清理掉。

缺点：可使用的内存只有原来的一半。

4、分代收集算法

当前主流JVM都采用分代收集算法，这种算法会根据对象存活周期的不同将内存划分为年轻代、年老代、永久代，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。

## JVM调优参数

- -Xmx：设置jvm最大可用内存

- -Xms：设置jvm初始内存

- -Xmn：设置年轻代大小，整个jvm内存大小=年轻代大小+年老代大小+持久代大小。推荐配置为整个堆的3/8。

- -Xss：这是每个线程的栈大小

- -XX:NewRatio=4：设置年轻代（包括Eden和两个survivor区）与年老代的壁纸（除去持久代）。设置为4，则年轻代与年老代所占比值为1:4（默认为2）

- -XX:SurvivorRatio=4：设置年轻代中Eden区域Survivor区的大小比值。设置为4，则两个Survivor区域一个Eden区的比值为2:4。

# java中的四种引用类型

1、强引用

在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收，一次强引用时造成java内存泄漏的主要原因之一。

```
M m = new M();
m=null;
System.gc();
System.out.println(sr.get());//null
```

2、软引用

软引用需要用SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

```
SoftReference<byte[]> sr = new SoftReference<>(new byte[1024 * 1024 * 10]);
System.out.println(sr.get()); // 地址
System.gc();
System.out.println(sr.get()); // 地址
byte[] b = new byte[1024 * 1024 * 12];
System.out.println(sr.get()); // null
```

3、弱引用

弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。

```
WeakReference<M> wr = new WeakReference<>(new M());
System.out.println(wr.get()); // 获取到值
System.gc();
SleepHelper.sleepSeconds(1);
System.out.println(wr.get()); // null
```

4、虚引用

虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

```
private static final List<Object> LIST = new LinkedList<>();
private static final ReferenceQueue<M> QUEUE = new ReferenceQueue<>();
public static void main(String[] args) {
    PhantomReference<M> phantomReference = new PhantomReference<>(new M(), QUEUE);
    System.out.println(phantomReference.get()); //null
    ByteBuffer b = ByteBuffer.allocateDirect(1024);
    new Thread(()->{
        while(true){
            LIST.add(new byte[1024 * 1024]);
            SleepHelper.sleepSeconds(1);
            System.out.println(phantomReference.get());
        }
        // 内存不足之后，M对象会被回收，会放入到QUEUE中
    }).start();
    new Thread(()->{
        while(true){
            Reference<? extends M> poll = QUEUE.poll();
            if(poll != null) {
                System.out.println("---虚引用对象被JVM回收了---" + poll);
            }
        }
    }).start();
}
```

## 内存泄漏

指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

## 内存溢出

指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。

# 类加载器

## 类加载器分类

1、启动类加载器

没有父加载器，用来加载Java的核心库，用于提供JVM自身需要的类

2、扩展类加载器

父类加载器为启动类加载器，从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载。

3、应用类加载器

父类加载器为扩展类加载器，负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。该类加载是程序中默认的类加载器,一般来说, Java应用的类都是由它来完成加载

4、自定义类加载器

可用于：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄漏

## 类什么时候被初始化

1. 创建类的实例，也就是new一个对象

2. 访问某个类或接口的静态变量，或者对该静态变量赋值

3. 调用类的静态方法

4. 反射

5. 初始化一个类的子类（会首先初始化子类的父类）

6. JVM启动时标明的启动类，即文件名和类名相同的那个类

只有这6种情况才会导致类的初始化，类的初始化步骤：

（1）如果这个类还没有被加载和链接，那先进行加载和链接

（2）加入这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）

（3）加入类中存在初始化语句（如static变量和static块），那就一次执行这些初始化语句

## 双亲委派模型

指一个类接收到类加载请求后，会把这个请求一次传递给父类加载器（如果还有），如果顶层的父类加载器可以加载，就成功返回，如果如法加载，再一次给子加载器去加载。

作用：

1. 保护程序安全，防止核心API被随意篡改。在java.lang包下，开发者自定义的类中的main方法不允许执行，复制恶意代码对程序产生破坏。

2. 避免类的重复加载。一个类只会被加载一次。

## JVM加载class过程

当程序主动使用某个类是，如果这个类还未被加载到内存中，则系统会通过三个步骤对类进行初始化：加载、链接（验证、准备和解析）、初始化。

（1）类的加载

将类的class文件加载到内存中，放在运行区域的方法区内，然后在堆中创建java.lang.Class对象，用来封装类在方法区的数据结构。

（2）类的链接

将java类的二进制数据合并到jvm运行状态中

一、验证：确保类复合jvm规范，保证安全性；验证过程分为四个阶段。

> 1. 文件格式验证，验证字符流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理
> 
> 2. 元数据验证，是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范要求。
> 
> 3. 字节码验证，主要是进行数据流和控制流的分析，保证被校验类的方法在允许时不会危害虚拟机。
> 
> 4. 符号引用验证，符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。

二、准备：准备阶段为变量分配内存并设置变量的初始化。

> 在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量。对已非final的变量，JVM会将其设置零值，而不是其赋值语句的值：private static int size = 12。那么在这个阶段，size的值为0，而不是12。但final修饰的类变量将会赋值成真实的值。

三、解析：jvm常量池中的符号引用（常量名）直接替换成直接引用（地址）

> 主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。

（3）类的初始化：初始化，则是为标记为常量值的字段赋值的过程。

> 换句话说，只对static修饰的变量或语句块进行初始化。
> 
> 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
> 
> 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

# 队列

# 集合
